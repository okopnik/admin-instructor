#!/usr/bin/perl -l
# By Ben Okopnik 11/27/2013 Version 0.94
# Sanity checker for Hadoop conffile <name> tags
#
# Copyright 2013 Ben Okopnik
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

############ User-configurable ####################
# Source file URL
my $source_http = 'http://okopnik.com/Cloudera';
# Toggle debugging messages (0/1)
my $debug = 0;
############ User-configurable ####################

use warnings;
use strict;

my ($k, %data, %deprecated);

# Get the conf data
die "You need to install 'wget'. Aborting...\n" unless -f '/usr/bin/wget';
my $fetch = qx[/usr/bin/wget -q $source_http/confcheck.data -O -];
die "Fetch failed; check your network connection.\n" if length($fetch) < 1024;

# Name validation pattern
my $pat = qr{(?:[-\w]+\.)+[-\w]+};

# Populate validator hash
for (split /\n/, $fetch){
    chomp;
    next if /^\s*(?:#|$)/;
    # Section headers
    if (m#^(deprecated)\s*$|^(/.*)-(?:site|default)\.xml\s*$#){
        $k = $+;
        next;
    }

    s/^\s*|\s*$//;

    if ($k eq 'deprecated'){
        die "Incorrect input format in the '$k' section; please report to maintainer!\n"
            unless /^$pat\s+$pat$/;
        my ($a, $b) = split;
        $deprecated{$a} = $b;
    }
    else {
        die "Incorrect input format in the '$k' section; please report to maintainer!\n"
            unless /^$pat$/;
        # Fully populate both the '-default' and the '-site' versions
        $data{"$k-default.xml"}{$_}++;
        $data{"$k-site.xml"}{$_}++;
    }
}

# Basic, but hopefully sufficient, XML validation
sub valid_xml {
    my $fn = shift;
    my $xml = shift;
    die "'$fn' contains no data\n" unless $xml;

    my $l;

    # Get rid of standard header and any comment lines
    $xml =~ s/<\?xml[^>]+>//gs;
    $xml =~ s/<!--.*?-->//gs;

    do {
        $l = length($xml);
        # "Eat" the smallest innermost chunk not containing a tag
        $xml =~ s#<([^ >]+)(?: [^>]+)?>([^<>]*)</\1>##s;
        # Once there are no more tagged entities, check for remaining content
        if (defined $1){
            print "$fn: <$1></$1> match" if $debug;
        }
        else {
            if ($xml =~ /\S/){
                $xml =~ s/\s*\n+/\n/gs;
                print "WARNING: Possible malformed tag structure in '$fn'";
                print "\n$1\n" if $xml =~ m#(<[^>]+>[^<]*</[^>]+>)#;
		print $xml if $debug;
                exit 1;
            }
        }
    } while length($xml) < $l;
}

my @fchecked;
my $err = 0;
for my $file (keys %data){
    next unless -f $file;
    push @fchecked, $file;
    open my $Fh, '<', $file or die "$file: $!\n";
    my $xml = my $content = do { local $/; <$Fh>; };
    close $Fh;

    valid_xml($file, $xml);

    print "Reading '$file':" if $debug;
    for my $name ($content =~ m[<name>\s*([^<]+?)\s*</name>]g){
        if (!exists $data{$file}{$name}){
            if (exists $deprecated{$name}){
                print "\tNOTE: '$name' is deprecated; use '$deprecated{$name}' instead.";
            }
            else {
                print "\t$file: '$name' is not a valid property name.";
            }
            $err++;
        }

    }
}

if ($debug){
    $" = "\n\t";
    print $err?"$err":"No", " property name error", $err==1?"":"s", " found in\n\t@fchecked",
        unless @fchecked == 0;
}
